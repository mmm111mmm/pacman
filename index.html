<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, maximum-scale=1, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Pacman</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">    
    <style>
        .beginScreen {
            position: absolute; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background-color: gray;
        }
        .beginScreen * {
            padding: 4px;
        }
        .beginScreen .btn {
            background-color: green;
            color: white;
            padding: 5px;
            font-size: 14px;
            text-transform: uppercase;
        }
        @media (min-width: 800px) {
            .beginScreen {
                height: 400px;
                width: 400px;
            }
            canvas {
                height: 400px;
                width: 400px;
            }
            .controls {
                height: 40px;
            }
        }
        @media (max-width: 800px) {
            .beginScreen {
                height: 88vh;
                width: 98vw;
            }
            canvas {
                height: 88vh;
                width: 98vw;
            }
            #container {
                height: 98vh;
                width: 98vw;
            }
            .controls {
                height: 10vh;
            }
        }
        .controls {
            display: flex;
            overflow: hidden;
        }
        .controls {
            margin: 0px;
            padding: 0px;
            margin-left: 3px;
            margin-right: 3px;
            font-size: 40px;
            color: gray;
        }
        #container {
            position: relative;
        }
        body {
            padding-left: 1vw;
            padding-right: 1vw;
            padding-top: 1vw;
            padding-bottom: 1vw;
            margin: 0px;
            font-family: sans-serif;
            overflow: hidden;
        }
        .score {
            font-size: 16px;
            bottom: 0px;  
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            padding-left: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="beginScreen">
            <div>The classic game, pacman.</div>
            <div class="btn">eat some 'sweets'</div>
        </div>
        <canvas id="myCanvas"></canvas>       
        <div class="controls">
            <div class="score">Score</div>
        </div>  
    </div>
</body>

<script>

    // grid for proper pacman game
    // ghosts spawn from middle
    // score for pills

    document.querySelector(".beginScreen").onclick = function(event) {
        gameStart()
    }

    var grid = [
        ['w','w','w','w','w','w','w','w','w','w'],
        ['w','.','.','.','.','.','.','.','.','w'],
        ['w','.','w','.','w','w','w','w','.','w'],
        ['w','.','w','.','.','w','w','w','.','w'],
        ['w','.','w','w','.','.','.','w','.','w'],
        ['w','.','w','w','w','w','.','w','.','w'],
        ['w','.','.','.','.','.','.','.','w','w'],
        ['w','w','w','w','w','w','w','w','w','w']
    ]

    var gameLoop;
    var canvasWidth;
    var canvasHeight;
    var gridSize = 20;
    var score = 0;
    var ctx;

    function Ghost(x, y) {
        this.x = x * gridSize
        this.y = y * gridSize
        this.ghostSprite = new Animan({ sprite: './ghost.png', row: 0, numCols: 8, numRows: 1})
        this.directionX = 0
        this.directionY = 0
        this.nextY = null
        this.nextX = null
    }
    Ghost.prototype.move = function() {
        this.x += this.directionX;
        this.y += this.directionY;
        if((this.x == this.nextX) ||
            (this.y == this.nextY))  {
            this.nextX = null;
            this.nextY = null;
            this.directionX = 0;
            this.directionY = 0;
        }
        if(!this.nextY && !this.nextX && !this.tryToChasePacman()) {
            this.chooseRandomDirection()
        }
        this.changeSpriteBasedOnDirection()
    }
    Ghost.prototype.changeSpriteBasedOnDirection = function() {
        if(this.directionY > 0) {
            this.ghostSprite.animate({ col: 6, colNum: 2 })
        } else if (this.directionY < 0) {
            this.ghostSprite.animate({ col: 4, colNum: 2 })
        } else if(this.directionX > 0) {
            this.ghostSprite.animate({ col: 0, colNum: 2 })
        } else if(this.directionX < 0) {
            this.ghostSprite.animate({ col: 2, colNum: 2 })
        }    
    }
    Ghost.prototype.tryToChasePacman = function() {
        var x = Math.round(this.x / gridSize);
        var y = Math.round(this.y / gridSize);
        var pX = Math.round(pacman.x / gridSize);
        var pY = Math.round(pacman.y / gridSize);
        var canSee = false
        if(y == pY) {
            if(pX < x) 
                for(var i = x - 1, canSee = true; i > pX && canSee; i--)
                    canSee = grid[y][i] != "w"
            else if(pX > x) 
                for(var i = x + 1, canSee = true; i < pX && canSee; i++)
                    canSee = grid[y][i] != "w"
            if(canSee) {
                this.nextX = pacman.x
                this.directionX = (pX < x) ? -1: 1;
                return true;
            }
        } else if(x == pX) {
            if(pY < y) 
                for(var i = y - 1, canSee = true; i > pY && canSee; i--)
                    canSee = grid[i][x] != "w"
            else if(pY > y) 
                for(var i = y + 1, canSee = true; i < pY && canSee; i++)
                    canSee = grid[i][x] != "w"
            if(canSee) {
                this.nextY = pacman.y
                this.directionY = (pY < y) ? -1: 1;
                return true;
            }
        }     
        return false;
    }
    Ghost.prototype.chooseRandomDirection = function() {
        var x = Math.round(this.x / gridSize);
        var y = Math.round(this.y / gridSize);
        console.log(x, y)
        var seenBlocks = [
            {y: y-1, x: x+0 },
            {y: y+1, x: x+0 },
            {y: y+0, x: x-1 },
            {y: y+0, x: x+1 },
        ]
        .filter(b => {
            return grid[b.y] && grid[b.y][b.x] && grid[b.y][b.x] != "w"
        })
        var block = Math.floor(Math.random() * (seenBlocks.length))
        block = seenBlocks[block]
        if(block.y == y) {
            this.nextX = block.x * gridSize
            this.directionX = block.x > x ? 1 : -1
        } else {
            this.nextY = block.y * gridSize
            this.directionY = block.y > y ? 1 : -1
        }            
    }

    var pacman = {
        x: gridSize, y: gridSize, 
        nextX: null, nextY: null,
        pacmanSprite: new Animan({ sprite: './pacman.png', row: 0, numCols: 2, numRows: 4}),
        directionX: 0, directionY: 0,
        changeSpriteBasedOnDirection: function() {
            if(pacman.directionY > 0) {
                pacman.pacmanSprite.animate({ row: 3, col: 0, colNum: 2 })
            } else if (pacman.directionY < 0) {
                pacman.pacmanSprite.animate({ row: 2, col: 0, colNum: 2 })
            } else if(pacman.directionX > 0) {
                pacman.pacmanSprite.animate({ row: 0, col: 0, colNum: 2 })
            } else if(pacman.directionX < 0) {
                pacman.pacmanSprite.animate({ row: 1, col: 0, colNum: 2 })
            }
        },
        startStepingVertical: function(dir = 1) {
            if(pacman.nextX || !this.canMoveInDirection({dirY: dir})) return
            pacman.directionY = 2 * dir
            var remaining;
            if(dir > 0) remaining = gridSize - (pacman.y % gridSize)
            else remaining = pacman.y % gridSize
            if(remaining == 0) remaining = gridSize
            pacman.nextY = pacman.y + (remaining * dir)
        }, 
        startStepingHorizontal: function(dir = 1) {
            if(pacman.nextY || !this.canMoveInDirection({dirX: dir})) return
            pacman.directionX = 2 * dir
            var remaining
            if(dir > 0) remaining = gridSize - (pacman.x % gridSize)
            else remaining = pacman.x % gridSize
            if(remaining == 0) remaining = gridSize
            pacman.nextX = pacman.x + (remaining * dir)
        },
        canMoveInDirection: function({dirX=0, dirY=0}) {
            var x = Math.round(this.x / gridSize);
            var y = Math.round(this.y / gridSize);        
            var sx = x + ((dirX > 0) ? 1 : 0)
            sx = sx + ((dirX < 0) ? -1 : 0)
            var sy = y + ((dirY > 0) ? 1 : 0)
            sy = sy + ((dirY < 0) ? -1 : 0)
            return grid[sy][sx] != "w"            
        },
        moveAndInteractWithGrid: function() {
            pacman.y += pacman.directionY;
            pacman.x += pacman.directionX;

            var x = Math.round(this.x / gridSize);
            var y = Math.round(this.y / gridSize);        
            var b = grid[y][x]
            if(b == '.') {
                grid[y][x] = ' '
            }

            ghosts.forEach(g => {
                var gx = Math.round(g.x / gridSize);
                var gy = Math.round(g.y / gridSize);        
                if(x == gx && y == gy) {
                    gameOver()
                }
            })      

            this.changeSpriteBasedOnDirection()
            // stop movement if reached place
            if((pacman.nextX && pacman.x == pacman.nextX) 
            || (pacman.nextY && pacman.y == pacman.nextY)) {
                pacman.directionX = 0;
                pacman.directionY = 0;
                pacman.nextX = null;
                pacman.nextY = null;            
                pacman.pacmanSprite.animate({turnOff: true});
            }            
        }
    }

    var ghosts = [
        new Ghost(8, 5),
        new Ghost(2, 6),
    ]

    function draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight)       
        grid.forEach((r, y) => {
            r.forEach((b, x) => {
                if(b == "w") {
                    ctx.fillStyle = "brown"
                    ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize)
                } else if(b == ".") {
                    ctx.fillStyle = "black"
                    ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize)
                    ctx.fillStyle = "white"
                    ctx.beginPath()
                    ctx.arc(x*gridSize + gridSize / 2, y*gridSize + gridSize / 2, 2, 0, 2 * Math.PI)
                    ctx.fill()
                }
            })
        })
        pacman.pacmanSprite.draw(pacman.x, pacman.y)
        ghosts.forEach(g => 
            g.ghostSprite.draw(g.x, g.y)
        )
        
    }

    window.onkeydown = function(event) {
        event.preventDefault()
        if(event.keyCode == 39) {
            pacman.startStepingHorizontal()
        }
        else if(event.keyCode == 37) {
            pacman.startStepingHorizontal(-1)
        }
        else if(event.keyCode == 38) {
            pacman.startStepingVertical(-1)
        }
        else if(event.keyCode == 40) {
            pacman.startStepingVertical()
        }
    }

    function gameOver() {
        document.querySelector(".beginScreen").style.display = "flex"
        cancelAnimationFrame(gameLoop)
        gameLoop = null
    }

    function gameStart() {
        document.querySelector(".beginScreen").style.display = "none";
        var c = document.getElementById("myCanvas");
        ctx = c.getContext("2d");
        ghosts = [
            new Ghost(8, 5),
            new Ghost(2, 6),
        ]        
        canvasWidth = c.clientWidth;
        canvasHeight = c.clientHeight;
        c.setAttribute("width", canvasWidth);
        c.setAttribute("height", canvasHeight);
        score = 0;
        gameLoop = function() {
            pacman.moveAndInteractWithGrid()
            ghosts.forEach(g => 
                g.move()
            )            
            draw();
            if(gameLoop) requestAnimationFrame(gameLoop)
        }
        requestAnimationFrame(gameLoop)
    }

    gameStart()

    function Animan({sprite, row, numCols, numRows}) {
        this.img = new Image();
        this.img.src = sprite;
        this.imageFrameNumber = 1; // This is changed to make the sprite animate  
        this.row = row;
        this.img.onload = function() {
            this.heightOfImage = this.img.height / numRows; // find the height of the image
            this.widthOfImage = this.img.width / numCols; // The width of each image in the spirite
        }.bind(this)
    }

    Animan.prototype.draw = function(x, y, gridSize = 20) {
        if(!this.widthOfImage) return
        ctx.drawImage(this.img, 
            this.imageFrameNumber * this.widthOfImage, this.heightOfImage * this.row, // x and y - where in the sprite
            this.widthOfImage, this.heightOfImage, // width and height
            x, y, // x and y - where on the screen
            gridSize, gridSize // width and height
        );           
    }

    Animan.prototype.animate = function({ turnOff = false, row, col = 0, colNum }) {
        if(row || row == 0) this.row = row;
        if(col || col == 0) this.startSprite = col;        
        if(turnOff && this.animationFrame) {
            clearInterval(this.animationFrame);
            this.animationFrame = undefined;
            this.imageFrameNumber = 1;     
        } else if(!turnOff && !this.animationFrame) {
            this.animationFrame = setInterval(function() {
                this.imageFrameNumber++; // changes the sprite we look at
                this.imageFrameNumber = this.startSprite + this.imageFrameNumber % colNum; // Change this from 0 to 1 to 2 ... upto 9 and back to 0 again, then 1...
            }.bind(this), 80)
        }
    }

</script>
</html>