<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, maximum-scale=1, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Pacman</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">    
    <style>
        .beginScreen {
            position: absolute; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background-color: gray;
        }
        .beginScreen * {
            padding: 4px;
        }
        .beginScreen .btn {
            background-color: green;
            color: white;
            padding: 5px;
            font-size: 14px;
            text-transform: uppercase;
        }
        .beginScreen {
            height: 100vh;
            width: 100vw;
        }
        canvas {
            height: 100vh;
            width: 100vw;
        }
        #container {
            position: relative;
        }
        body {
            margin: 0px;
            font-family: sans-serif;
            overflow: hidden;
        }
        .score {
            font-size: 16px;
            bottom: 0px;  
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            background-color: yellow;
            margin: 10px;
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="beginScreen">
            <div>The classic game, pacman.</div>
            <div class="btn">eat some 'sweets'</div>
            <div class="score"></div>
        </div>
        <canvas id="myCanvas"></canvas>       
    </div>
</body>

<script>

    // coloured ghosts
    // power up pills?
    // level complete!
    // loading of sprites

    document.querySelector(".beginScreen").onclick = function(event) {
        gameStart()
    }

    var grid = []
    var originalGrid = [
        ['w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w'],
        ['w','.','.','.','.','.','.','.','.','w','.','.','.','.','.','.','.','.','w'],
        ['w','.','w','w','.','w','w','w',',','w','.','w','w','w','.','w','w','.','w'],
        ['w','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','w'],
        ['w','.','w','w','.','w','.','w','w','w','w','w','.','w','.','w','w','.','w'],
        ['w','.','.','.','.','w','.','.','.','w','.','.','.','w','.','.','.','.','w'],
        ['w','w','w','w','.','w','w','w','.','w','.','w','w','w','.','w','w','w','w'],
        ['.','.','.','w','.','w','.','.','.','.','.','.','.','w','.','w','.','.','.'],
        ['w','w','w','w','.','w','.','w','w','.','w','w','.','w','.','w','w','w','w'],
        ['.','.','.','.','.','.','.','w','.','.','.','w','.','.','.','.','.','.','.'],
        ['w','w','w','w','.','w','.','w','w','w','w','w','.','w','.','w','w','w','w'],
        ['.','.','.','w','.','w','.','.','.','.','.','.','.','w','.','w','.','.','.'],
        ['w','w','w','w','.','w','.','w','w','w','w','w','.','w','.','w','w','w','w'],
        ['w','.','.','.','.','.','.','.','.','w','.','.','.','.','.','.','.','.','w'],
        ['w','.','w','w','.','w','w','w',',','w','.','w','w','w','.','w','w','.','w'],
        ['w','.','.','w','.','.','.','.','.','.','.','.','.','.','.','w','.','.','w'],
        ['w','w','.','w','.','w','.','w','w','w','w','w','.','w','.','w','.','w','w'],
        ['w','.','.','.','.','w','.','.','.','w','.','.','.','w','.','.','.','.','w'],
        ['w','.','w','w','w','w','w','w','.','w','.','w','w','w','w','w','w','.','w'],
        ['w','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','w'],
        ['w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w','w'],
    ]

    var gameLoop;
    var gridSize = 20;
    var score = 0;
    var c = document.getElementById("myCanvas");
    var ctx;

    var pr1 = new Image(); pr1.src = './pr1.png'
    var pr2 = new Image(); pr2.src = './pr2.png'
    var pl1 = new Image(); pl1.src = './pl1.png'
    var pl2 = new Image(); pl2.src = './pl2.png'
    var pu1 = new Image(); pu1.src = './pu1.png'
    var pu2 = new Image(); pu2.src = './pu2.png'
    var pd1 = new Image(); pd1.src = './pd1.png'
    var pd2 = new Image(); pd2.src = './pd2.png'
    var gu1 = new Image(); gu1.src = './gu1.png'
    var gu2 = new Image(); gu2.src = './gu2.png'
    var gd1 = new Image(); gd1.src = './gd1.png'
    var gd2 = new Image(); gd2.src = './gd2.png'
    var gl1 = new Image(); gl1.src = './gl1.png'
    var gl2 = new Image(); gl2.src = './gl2.png'
    var gr1 = new Image(); gr1.src = './gr1.png'
    var gr2 = new Image(); gr2.src = './gr2.png'
    
    // A ghost in the pacman game
    function Ghost(x, y) {
        this.x = x * gridSize
        this.y = y * gridSize
        this.directionX = 0
        this.directionY = 0
        this.nextY = null // where we're aiming for
        this.nextX = null // where we're aiming for

        this.currAnim = [gu1, gu2]
        this.animIter = 0
        this.img = gu1 // what we draw to the screen
        if(this.animLoop) clearInterval(this.animLoop)
        this.animLoop = setInterval(function() {
            this.animIter = (++this.animIter) % this.currAnim.length
            this.img = this.currAnim[this.animIter]
        }.bind(this), 120)        
    }
    // Move or stop if we get to desired location
    Ghost.prototype.move = function() {
        this.x += this.directionX;
        this.y += this.directionY;
        if((this.x == this.nextX) || (this.y == this.nextY))  {
            this.nextX = null;
            this.nextY = null;
            this.directionX = 0;
            this.directionY = 0;
        }
        // If we've nowhere to go
        if(!this.nextY && !this.nextX && !this.tryToChasePacman()) {
            this.chooseRandomDirection()
        }
        this.changeSpriteBasedOnDirection()
    }
    Ghost.prototype.changeSpriteBasedOnDirection = function() {
        if(this.directionY > 0) this.currAnim = [gd1, gd2]
        else if(this.directionY < 0) this.currAnim = [gu1, gu2]
        else if(this.directionX > 0) this.currAnim = [gr1, gr2]
        else if(this.directionX < 0) this.currAnim = [gl1, gl2]
    }
    // See if we're on the same path as pacman
    // and if there's no walls inbetween.
    // And if not, then set our nextX/Y to pacman.
    Ghost.prototype.tryToChasePacman = function() {
        var x = Math.round(this.x / gridSize);
        var y = Math.round(this.y / gridSize);
        var pX = Math.round(pacman.x / gridSize);
        var pY = Math.round(pacman.y / gridSize);
        var canSee = false
        if(y == pY) {
            var max = Math.max(x, pX)
            for(var i = Math.min(x, pX) + 1, canSee = true; i < max && canSee; i++)
                canSee = grid[y][i] != "w"
            if(canSee) {
                this.nextX = pacman.x
                this.directionX = (pX < x) ? -1: 1;
            }
        } else if(x == pX) {
            var max = Math.max(y, pY)
            for(var i = Math.min(y, pY) + 1, canSee = true; i < max && canSee; i++)
                canSee = grid[i][x] != "w"
            if(canSee) {
                this.nextY = pacman.y
                this.directionY = (pY < y) ? -1: 1;
            }
        }     
        return canSee;
    }
    // Look up, down, left and right
    // then chose a random direction.
    Ghost.prototype.chooseRandomDirection = function() {
        var x = Math.round(this.x / gridSize);
        var y = Math.round(this.y / gridSize);
        var seenBlocks = [
            {y: y-1, x: x+0 },
            {y: y+1, x: x+0 },
            {y: y+0, x: x-1 },
            {y: y+0, x: x+1 },
        ]
        .filter(b => {
            return grid[b.y] && grid[b.y][b.x] && grid[b.y][b.x] != "w"
        })
        var block = Math.floor(Math.random() * (seenBlocks.length))
        block = seenBlocks[block]
        if(block.y == y) {
            this.nextX = block.x * gridSize
            this.directionX = block.x > x ? 1 : -1
        } else {
            this.nextY = block.y * gridSize
            this.directionY = block.y > y ? 1 : -1
        }            
    }

    // Single object for the pacman character
    var pacman = {
        currAnim: [pr1, pr2],
        animIter: 0,
        img: pr1, // what we draw to the screen
        init: function() {
            this.x = gridSize // pos 1,1
            this.y = gridSize // pos 1,1
            this.directionX = 0
            this.directionY = 0
            this.requestX = 0 // we request to go forward (1) or back (-1)
            this.requestY = 0 // we request to go right (1) or left (-1)
            if(this.animLoop) clearInterval(this.animLoop)
            this.animLoop = setInterval(function() {
                this.animIter = (++this.animIter) % this.currAnim.length
                this.img = this.currAnim[this.animIter]
            }.bind(this), 120)
        },
        changeSpriteBasedOnDirection: function() {
            if(pacman.directionY > 0) this.currAnim = [pd1, pd2]
            else if(pacman.directionY < 0) this.currAnim = [pu1, pu2]
            else if(pacman.directionX > 0) this.currAnim = [pr1, pr2]
            else if(pacman.directionX < 0) this.currAnim = [pl1, pl2]
        },
        // Is our suggested movement a wall?
        canMoveInRequestDirection: function() {
            var x = this.x / gridSize;
            var y = this.y / gridSize;        
            var sx = x + ((this.requestX > 0) ? 1 : 0)
            sx = sx + ((this.requestX < 0) ? -1 : 0)
            var sy = y + ((this.requestY > 0) ? 1 : 0)
            sy = sy + ((this.requestY < 0) ? -1 : 0)
            return grid[sy][sx] != "w"
        },
        // We process direction requests when exactly on a grid peice
        perfectlyOnAGridPeice: function() {
            return ((this.x / gridSize) % 1) == 0 
               && ((this.y / gridSize) % 1) == 0
        },
        // Try to move directions, move, eat pills
        moveAndInteractWithGrid: function() {
            // Process direction request
            // or stop if we'd hit a wall
            if(this.perfectlyOnAGridPeice()) {
                if(this.canMoveInRequestDirection()) {
                    pacman.directionX = pacman.requestX
                    pacman.directionY = pacman.requestY
                } else {
                    pacman.directionX = 0
                    pacman.directionY = 0
                }
            }
            // move
            pacman.y += pacman.directionY;
            pacman.x += pacman.directionX;
            // eat a pill
            var x = Math.round(this.x / gridSize);
            var y = Math.round(this.y / gridSize);        
            var b = grid[y][x]
            if(b == '.') {
                grid[y][x] = ' '
                score++
            }
            // Change sprite direction
            this.changeSpriteBasedOnDirection()        
        }
    }

    // Blank the screen, draw the grid, 
    // draw pacman and draw the ghosts
    function draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, c.clientWidth, c.clientHeight)       
        grid.forEach((r, y) => {
            r.forEach((b, x) => {
                if(b == "w") {
                    ctx.fillStyle = "#0900ff"
                    ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize)
                } else if(b == ".") {
                    ctx.fillStyle = "black"
                    ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize)
                    ctx.fillStyle = "white"
                    ctx.beginPath()
                    ctx.arc(x*gridSize + gridSize / 2, y*gridSize + gridSize / 2, 2, 0, 2 * Math.PI)
                    ctx.fill()
                }
            })
        })
        ctx.drawImage(pacman.img, pacman.x, pacman.y, gridSize, gridSize)
        ghosts.forEach(g => 
            ctx.drawImage(g.img, g.x, g.y, gridSize, gridSize)
        )
        ctx.fillStyle = "lightgrey"
        ctx.font = "14px sans-serif"
        ctx.fillText("Score: " + score, 4, grid.length*gridSize+gridSize)
    }

    window.onkeydown = function(event) {
        event.preventDefault()
        // request X/Y must be multiple of 20
        // so we fit into grid for direction change
        if(event.keyCode == 39) {
            pacman.requestY = 0
            pacman.requestX = 1             
        } else if(event.keyCode == 37) {
            pacman.requestY = 0
            pacman.requestX = -1
        } else if(event.keyCode == 38) {
            pacman.requestY = -1
            pacman.requestX = 0
        } else if(event.keyCode == 40) {
            pacman.requestY = 1
            pacman.requestX = 0
        }
    }

    function gameOver() {
        document.querySelector(".beginScreen").style.display = "flex"
        document.querySelector(".score").innerHTML = "Score: " + score
        gameLoop = null
    }

    function gameStart() {
        document.querySelector(".beginScreen").style.display = "none";
        ctx = c.getContext("2d");
        grid = JSON.parse(JSON.stringify(originalGrid))
        ghosts = [
            new Ghost(8, 9),
            new Ghost(8, 9),
            new Ghost(8, 9),
            new Ghost(8, 9),
        ]        
        pacman.init()
        c.setAttribute("width", c.clientWidth);
        c.setAttribute("height", c.clientHeight);
        score = 0;
        gameLoop = function() {
            pacman.moveAndInteractWithGrid()
            var x = Math.round(pacman.x / gridSize);
            var y = Math.round(pacman.y / gridSize);        
            ghosts.forEach(g => {
                g.move()
                var gx = Math.round(g.x / gridSize);
                var gy = Math.round(g.y / gridSize);        
                if(x == gx && y == gy) {
                    gameOver()
                }
            })
            draw();
            if(gameLoop) requestAnimationFrame(gameLoop)
        }
        requestAnimationFrame(gameLoop)
    }

    gameStart()

</script>
</html>